<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>EPGSmod</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; padding: 20px; background: #f4f4f4; }
    h1 { font-size: 1.4rem; text-align: center; }
    .card { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    select,input,button { width: 100%; margin-top: 10px; padding: 10px; }
    #log { background: black; color: #0f0; padding: 10px; height: 150px; overflow-y: auto; }
</style>
</head>
<body>

<h1>ğŸ“º ã‚¸ãƒ£ãƒ³ãƒ«æ¤œç´¢ & äºˆç´„</h1>

<div class="card">
    <h3>ğŸŒ EPGStationè¨­å®š</h3>
    <input type="url" id="epgApiUrl" value="http://localhost:8888" placeholder="ä¾‹: http://localhost:8888">
    <button onclick="saveApiUrl()">URLã‚’ä¿å­˜</button>
</div>

<div class="card">
    <h3>1. ã‚¸ãƒ£ãƒ³ãƒ«é¸æŠ</h3>
    <select id="limitSelect">
      <option value="10">10 ä»¶</option>
      <option value="50">50 ä»¶</option>
      <option value="100">100 ä»¶</option>
      <option value="200" selected>200 ä»¶</option>
    </select>
    <select id="genreSelect"></select>
    <button onclick="searchSchedules()">æ¤œç´¢</button>
</div>

<div class="card">
    <h3>2. ç•ªçµ„é¸æŠ</h3>

    <select id="programList" size="6" onchange="selectProgram()"></select>

    <!-- â˜… ã€Œ[æ–°]ã®ã¿è¡¨ç¤ºã€ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ -->
<div style="margin-top:6px;">
    <label style="display:flex; align-items:center; gap:4px; font-size:13px; white-space:nowrap;">
        <input type="checkbox" id="filterNewCheck" onchange="filterNewOnly()" style="margin:0;">
        ï¼»æ–°ï¼½ã®ã¿è¡¨ç¤º
    </label>
</div>


</div>


<div class="card">
    <h3>3. ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰éŒ²ç”»ãƒ«ãƒ¼ãƒ«è¿½åŠ </h3>

    <input id="keywordInput" placeholder="ç•ªçµ„åãŒå…¥ã‚Šã¾ã™" style="width:100%; margin-bottom:8px;">

    <!-- æ¨ªä¸¦ã³ã®æ¤œç´¢ãƒœã‚¿ãƒ³ -->
    <div id="keywordSearchButtons" style="
        display: flex;
        gap: 6px;
        margin: 6px 0;
    ">
        <button class="mini-btn" onclick="searchExternal('duck')">DuckDuckGo</button>
        <button class="mini-btn" onclick="searchExternal('google')">Google</button>
        <button class="mini-btn" onclick="searchExternal('wiki')">Wikipedia</button>
    </div>

    <!-- æ¨ªã„ã£ã±ã„ã®éŒ²ç”»ãƒ«ãƒ¼ãƒ«è¿½åŠ ãƒœã‚¿ãƒ³ -->
    <button onclick="addRule()" style="
        width: 100%;
        padding: 10px;
        font-size: 15px;
        margin-top: 6px;
    ">
        éŒ²ç”»ãƒ«ãƒ¼ãƒ«è¿½åŠ 
    </button>
</div>

<div class="card">
    <h3>ãƒ­ã‚°</h3>
    <div id="log">Ready...</div>
</div>


<script src="extractProgram.js"></script>
<script>
// ====================================================================
// â–¼â–¼â–¼ API URLç®¡ç†ã®ãŸã‚ã®å¤‰æ•°ã®å®šç¾©ã¨é–¢æ•°ã®è¿½åŠ  â–¼â–¼â–¼
// ====================================================================

// APIãƒ™ãƒ¼ã‚¹URLã‚’ä¿æŒã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let EPG_API_BASE = 'http://localhost:8888'; 

// URLå…¥åŠ›æ¬„ã®å€¤ã‚’èª­ã¿è¾¼ã¿ã€å¤‰æ•°ã¨LocalStorageã«ä¿å­˜ã™ã‚‹é–¢æ•°
function saveApiUrl() {
    const inputElement = document.getElementById('epgApiUrl');
    // æœ«å°¾ã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤ã—ã€å¤‰æ•°ã«æ ¼ç´
    EPG_API_BASE = inputElement.value.trim().replace(/\/$/, ''); 
    alert(`EPGStation API URLã‚’ ${EPG_API_BASE} ã«è¨­å®šã—ã¾ã—ãŸã€‚`);
    // LocalStorageã«ä¿å­˜
    localStorage.setItem('epgApiUrl', EPG_API_BASE);
    log(`API URLè¨­å®š: ${EPG_API_BASE}`);
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®å‡¦ç†
document.addEventListener('DOMContentLoaded', () => {
    const savedUrl = localStorage.getItem('epgApiUrl');
    const inputElement = document.getElementById('epgApiUrl');
    
    // LocalStorageã«ä¿å­˜ã•ã‚ŒãŸURLãŒã‚ã‚Œã°å¾©å…ƒ
    if (savedUrl && inputElement) {
        inputElement.value = savedUrl;
        EPG_API_BASE = savedUrl;
    }
    log(`åˆæœŸAPI URL: ${EPG_API_BASE}`);
    
    // æ—¢å­˜ã®ã‚¸ãƒ£ãƒ³ãƒ«é¸æŠè‚¢ã®ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
    const genreSelect = document.getElementById('genreSelect');
    for (const [k,v] of Object.entries(genreMap)) {
        const op = document.createElement('option');
        op.value = k; op.textContent = v;
        genreSelect.appendChild(op);
    }
    genreSelect.value = "7";
});


// ====================================================================
// â–²â–²â–² API URLç®¡ç†ã‚»ã‚¯ã‚·ãƒ§ãƒ³çµ‚ã‚ã‚Š â–²â–²â–²
// ====================================================================

const genreMap = {
    0:"ãƒ‹ãƒ¥ãƒ¼ã‚¹",1:"ã‚¹ãƒãƒ¼ãƒ„",2:"æƒ…å ±",3:"ãƒ‰ãƒ©ãƒ",
    4:"éŸ³æ¥½",5:"ãƒãƒ©ã‚¨ãƒ†ã‚£",6:"æ˜ ç”»",7:"ã‚¢ãƒ‹ãƒ¡/ç‰¹æ’®",
    8:"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ã‚¿ãƒªãƒ¼",9:"åŠ‡å ´/å…¬æ¼”",10:"è¶£å‘³/æ•™è‚²",11:"ç¦ç¥‰"
};

// genreSelectã®åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ã¯DOMContentLoadedå†…ã«ç§»å‹•ã—ã¾ã—ãŸ

function log(msg){
    const el = document.getElementById('log');
    el.innerText = `[${new Date().toLocaleTimeString()}] ${msg}\n` + el.innerText;
}

async function searchSchedules(){
    const genreId = Number(genreSelect.value);

    // â˜… ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã® limit ã‚’å–å¾—
    const limit = Number(document.getElementById('limitSelect').value);

    const payload = {
        epgApiBase: EPG_API_BASE,
        isHalfWidth: false,
        option: {
            keyword: "",
            name: true, description: true, extended: true,
            GR: true, BS: false, CS: false, SKY: false,

            // subGenre ã‚’å¤–ã™ï¼ˆä»»æ„æ‰±ã„ï¼‰
            genres: [{ genre: genreId }]
        },

        // â˜… é¸æŠã•ã‚ŒãŸ limit ã‚’åæ˜ 
        limit: limit
    };

    try {
        const res = await fetch('/proxy/search', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await res.json();

        if (data && data.error) {
            log("æ¤œç´¢ã‚¨ãƒ©ãƒ¼: " + data.error);
            alert("æ¤œç´¢å¤±æ•—: " + data.error);
            return;
        }

        updateList(data);
        log(`æ¤œç´¢å®Œäº†: ${data.length} ä»¶`);
    } catch(e){
        log("æ¤œç´¢ã‚¨ãƒ©ãƒ¼: " + e.message);
        alert("æ¤œç´¢å¤±æ•—");
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ï¼ˆæ—¢ã«å®£è¨€ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ï¼‰
let originalProgramList = [];

// updateList ã®ä¿®æ­£ç‰ˆ
function updateList(list){
    const box = document.getElementById('programList');
    box.innerHTML = "";

    if (!Array.isArray(list)) {
        originalProgramList = [];
        return;
    }

    // 1) å—ã‘å–ã£ãŸä¸€è¦§ã‚’åŸæœ¬ã¨ã—ã¦ä¿æŒï¼ˆfilteråˆ‡æ›¿ã«ä½¿ç”¨ï¼‰
    originalProgramList = list.slice();

    // 2) åå‰æœ‰ã‚Šã®è¦ç´ ã ã‘å–ã‚Šå‡ºã—ã¦æ—¥æœ¬èªã‚½ãƒ¼ãƒˆ
    const filteredAndSorted = originalProgramList
        .filter(p => p && p.name) // p ãŒå­˜åœ¨ã— name ãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        .sort((a, b) => a.name.localeCompare(b.name, 'ja'));

    // 3) è¡¨ç¤ºç”¨ã« option ã‚’ä½œæˆï¼ˆé–‹å§‹æ—¥æ™‚ãŒã‚ã‚Œã°è¡¨ç¤ºã«å«ã‚ã‚‹ï¼‰
    filteredAndSorted.forEach(p => {
        const op = document.createElement('option');

        // startAt ãŒã‚ã‚‹ï¼æœ‰åŠ¹ãªæ—¥ä»˜ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        let startTime = "";
        if (p.startAt) {
            const d = new Date(p.startAt);
            if (!Number.isNaN(d.getTime())) {
                const mm = String(d.getMonth() + 1).padStart(2, '0');
                const dd = String(d.getDate()).padStart(2, '0');
                const hh = String(d.getHours()).padStart(2, '0');
                const mi = String(d.getMinutes()).padStart(2, '0');
                startTime = `${mm}/${dd} ${hh}:${mi}`; // ä¾‹: 12/10 18:00
            }
        }

        op.value = p.name; // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ã«ä½¿ã†å€¤ã¯ç•ªçµ„åã®ã¿
        op.textContent = startTime ? `[${startTime}] ${p.name}` : p.name;
        box.appendChild(op);
    });

    // 4) ç¾åœ¨ã€Œï¼»æ–°ï¼½ã®ã¿è¡¨ç¤ºã€ãŒã‚ªãƒ³ãªã‚‰çµã‚Šè¾¼ã‚€ï¼ˆåˆ‡æ›¿å¾Œã‚‚ä¸€è²«ã—ã¦å‹•ã‹ã™ãŸã‚ï¼‰
    const chk = document.getElementById('filterNewCheck');
    if (chk && chk.checked) {
        filterNewOnly(); // æ—¢ã«ç”¨æ„ã—ãŸé–¢æ•°ã‚’åˆ©ç”¨
    }
}

function filterNewOnly() {
    const listBox = document.getElementById("programList");
    listBox.innerHTML = "";

    if (!Array.isArray(originalProgramList)) return;

    const filter = document.getElementById('filterNewCheck').checked;

    let filtered = originalProgramList;
    if (filter) {
        filtered = originalProgramList.filter(x => {
            const n = x && x.name ? x.name : "";
            return n.includes("ï¼»æ–°ï¼½") || n.includes("[æ–°]");
        });
    }

    filtered.forEach(p => {
        if (!p || !p.name) return;
        const op = document.createElement("option");

        let startTime = "";
        if (p.startAt) {
            const d = new Date(p.startAt);
            if (!Number.isNaN(d.getTime())) {
                const mm = String(d.getMonth() + 1).padStart(2, '0');
                const dd = String(d.getDate()).padStart(2, '0');
                const hh = String(d.getHours()).padStart(2, '0');
                const mi = String(d.getMinutes()).padStart(2, '0');
                startTime = `${mm}/${dd} ${hh}:${mi}`;
            }
        }

        op.value = p.name;
        op.textContent = startTime ? `[${startTime}] ${p.name}` : p.name;
        listBox.appendChild(op);
    });
}
    
function parseProgramName(name) {
    if (!name) return "";
//     let title = name;
    let title = name.replace(/^ã€[^ã€‘]*ã€‘/, '').trim();

    // ä¾‹1: ï¼ƒ (å…¨è§’ãƒ»åŠè§’) ä»¥é™ã‚’å‰Šé™¤ã™ã‚‹
    // "ç•ªçµ„å #12 ã€Œã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«ã€" -> "ç•ªçµ„å "
    title = title.replace(/[#ï¼ƒ].*$/, '');
    // ä¾‹2: ã€ã€‘ã‚„[]ã§å›²ã¾ã‚ŒãŸç‰¹å®šã‚¿ã‚°ï¼ˆ[å­—] [å†]ãªã©ï¼‰ã‚’å‰Šé™¤ã—ãŸã„å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ãªè¡Œã‚’è¿½åŠ 
//     title = title.replace(/(\[.*?\]|ã€.*?ã€‘|ï¼ˆ.*?ï¼‰|\(.*\))/g, '');
    title = title.replace(/(\[.*?\]|ã€.*?ã€‘|\(.*\))/g, '');

    // --- ã€Œã‚¿ã‚¤ãƒˆãƒ«ï¼ˆ54ï¼‰ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æœ€å„ªå…ˆã§å‡¦ç† ---
    {
        const episodeParen = /^(.*?)[ï¼ˆ(][ï¼-ï¼™0-9]+[ï¼‰)]/;
        const m = title.match(episodeParen);
        if (m) return m[1].trim();
    }

    // Remove leading ã€...ã€‘
//     let filename = title.replace(/^ã€[^ã€‘]*ã€‘/, "");
    let filename = title

    // Delimiters used to detect program/episode split
    const delimiter_order = [
        "ï¼ƒ", "â™¯", "#", "ç¬¬", "æœ€çµ‚å›", "æœ€çµ‚è©±", "æœ€çµ‚é¦–",
        "(", "ï¼ˆ", "è©±", "â˜…", "â˜†", "â–¼", "â—†", "â–½",
        "ã€", "ã€Œ", "ã€", " ", "ã€€", "_", "["
    ];

    // Corresponding closing or secondary delimiters
    const delimiter_pairs = {
        "è©±": "",
        "ï¼ƒ": "_", "â™¯": "_", "#": "_", "ç¬¬": "_",
        "æœ€çµ‚å›": "_", "æœ€çµ‚è©±": "_", "æœ€çµ‚é¦–": "_",
        "(": ")", "ï¼ˆ": "ï¼‰",
        "â˜…": "_", "â˜†": "_", "â–¼": "_", "â–½": "_", "â—†": "_",
        " ": "_", "ã€€": "_",
        "ã€": "ã€‘", "ã€Œ": "ã€", "ã€": "ã€",
        "[": ".", "_": "."
    };

    let found_delimiter = "";
    let PROGRAM = "";
    let EPISODE = "";

    // Detect matching delimiter
    for (const d of delimiter_order) {
        if (filename.includes(d)) {
            found_delimiter = d;
            break;
        }
    }

    // Split by found delimiter
    if (found_delimiter) {
        const delimiter = found_delimiter;
        const pos = filename.indexOf(delimiter);

        PROGRAM = filename.slice(0, pos);
        let rest = filename.slice(pos + delimiter.length);

        const second = delimiter_pairs[delimiter];
        if (second && rest.startsWith(second)) {
            rest = rest.slice(second.length);
        }
        EPISODE = rest;

        // Reattach prefix (ç¬¬xxè©± â†’ ç¬¬)
        if (["ç¬¬", "æœ€çµ‚å›", "æœ€çµ‚è©±", "æœ€çµ‚é¦–"].includes(delimiter)) {
            EPISODE = delimiter + EPISODE;
        }
    } else {
        PROGRAM = filename;
    }

    // ORIGINAL for drama/anime parsing
    let ORIGINAL = PROGRAM
        .replace(/\[[^\]]*\]/g, "")
        .replace(/ã€[^ã€‘]*ã€‘/g, "")
        .replace(/ï¼œ[^ï¼]*ï¼/g, "")
        .replace(/[ ã€€]+/g, " ")
        .trim();

    // ---- DRAMA / MOVIE / ANIME quotation detection ----

    // Drama: ãƒ‰ãƒ©ãƒã€Œï½ã€
    if (/ãƒ‰ãƒ©ãƒ[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/ãƒ‰ãƒ©ãƒ[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    else  if (/ã‚µã‚¹ãƒšãƒ³ã‚¹[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/ã‚µã‚¹ãƒšãƒ³ã‚¹[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    else  if (/æ‡ãƒ‰ãƒ©[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/æ‡ãƒ‰ãƒ©[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    // Theater movie
    else if (/åŠ‡å ´[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/åŠ‡å ´[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    else if (/ãƒŸã‚¹ãƒ†ãƒªãƒ¼[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/ãƒŸã‚¹ãƒ†ãƒªãƒ¼[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    // Pure quoted title
    else if (/^[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/^[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    // Anime: ã‚¢ãƒ‹ãƒ¡ã€Œï½ã€
    else if (/ã‚¢ãƒ‹ãƒ¡[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/ã‚¢ãƒ‹ãƒ¡[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    // æ—¥ï¼•ã€Œï½ã€
    else if (/æ—¥ï¼•[^ã€Œã€]*[ã€Œã€][^ã€ã€]+[ã€ã€]/.test(ORIGINAL)) {
        const m = ORIGINAL.match(/æ—¥ï¼•[^ã€Œã€]*[ã€Œã€]([^ã€ã€]+)[ã€ã€]/);
        if (m) PROGRAM = m[1];
    }
    // Generic cleanup
    else {
        PROGRAM = ORIGINAL
            .replace(/ã€[^ã€‘]*ã€‘/g, '')  // â˜… Bash: -e 's/ã€[^ã€‘]*ã€‘//g' ã«ç›¸å½“ (å¯¾ã«ãªã£ãŸã‚‚ã®ã‚’å‰Šé™¤)
            .replace(/ï¼œ[^ï¼]*ï¼/g, '') // ï¼œã‚¿ã‚¤ãƒˆãƒ«ï¼
            .replace(/[ã€Œã€][^ã€ã€]*[ã€ã€].*/g, '') // ã€Œã‚¿ã‚¤ãƒˆãƒ«ã€ä»¥é™ã‚’å‰Šé™¤
            .replace(/â—†.*$/, '') // â—†ä»¥é™ã‚’å‰Šé™¤
            .replace(/â–¼.*$/, '') // â–¼ä»¥é™ã‚’å‰Šé™¤
            .replace(/â–½.*$/, '') // â–½ä»¥é™ã‚’å‰Šé™¤
            .replace(/^ã‚¢ãƒ‹ãƒ¡/, '') // å…ˆé ­ã® "ã‚¢ãƒ‹ãƒ¡" ã‚’å‰Šé™¤
            .replace(/ã€/g, '') // â˜… Bash: -e 's/ã€//g' ã«ç›¸å½“ (æ®‹ã£ãŸå…¨ã¦ã®ã€ã‚’å‰Šé™¤)
//.replace(/[ã€Œã€][^ã€ã€]*[ã€ã€].*/, "")
//            .replace(/[â—†â–¼â–½â˜†â˜…].*/, "")
           .replace(/ã‚¢ãƒ‹ãƒ¡ã®ç¥æ§˜/, "")
            .replace(/ãƒ—ãƒãƒ—ãƒãƒ»ã‚¢ãƒ‹ãƒ¡/, "")
            .replace(/ãƒŸãƒ‹ã‚¢ãƒ‹ãƒ¡/, "")
            .replace(/é™ç•Œã‚¢ãƒ‹ãƒ¡/, "")
            .replace(/ã‚¢ãƒ‹ãƒ¡/, "")
//            .replace(/ã€/, "")
            .replace(/[ ã€€]+$/, "")
            .replace(/^[ ã€€]+/, "")
            .replace(/[ ã€€].*/, "");
    }

    // Cleanup EPISODE
    EPISODE = EPISODE
        .replace(/\[[^\]]*\]/g, "")
        .replace(/__.*$/, "");

    // If PROGRAM becomes empty, fallback
    const MATCH_LIST = ["ã‚¢ãƒ‹ãƒ¡", "ãƒ—ãƒãƒ—ãƒãƒ»ã‚¢ãƒ‹ãƒ¡", "ãƒŸãƒ‹ã‚¢ãƒ‹ãƒ¡"];
    if (!PROGRAM || MATCH_LIST.includes(PROGRAM)) {
        PROGRAM = EPISODE;
    }

    return PROGRAM.trim();

    // å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤
//     return title.trim();
}

function selectProgram(){
    // å…ƒã®å‡¦ç†:
//    document.getElementById('keywordInput').value = document.getElementById('programList').value;
    
    // â–¼â–¼â–¼ å¤‰æ›´: ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’é€šã—ã¦ã‹ã‚‰ã‚»ãƒƒãƒˆã™ã‚‹ â–¼â–¼â–¼
    const rawName = document.getElementById('programList').value;
//     const cleanName = parseProgramName(rawName);
    const cleanName = extractProgram(rawName);
    document.getElementById('keywordInput').value = cleanName;
}

async function addRule(){
    const keyword = document.getElementById('keywordInput').value;
    if (!keyword) return alert("ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›");
    
    // â˜…â˜…â˜… ä¿®æ­£ç®‡æ‰€: EPG_API_BASEãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ â˜…â˜…â˜…
    if (!EPG_API_BASE || EPG_API_BASE.trim() === '') {
        log("ã‚¨ãƒ©ãƒ¼: EPG API URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        alert("EPG API URLã‚’è¨­å®šã—ã€[URLã‚’ä¿å­˜]ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚");
        return;
    }

    if (!confirm(`ã€Œ${keyword}ã€ã‚’ãƒ«ãƒ¼ãƒ«è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`)) return;

    // â˜…â˜…â˜… ä¿®æ­£ç®‡æ‰€: EPG_API_BASEã‚’JSONãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ  â˜…â˜…â˜…
    const payload = {
        // EPG_API_BASEã‚’ã‚µãƒ¼ãƒãƒ¼ã«ä¼ãˆã‚‹ãŸã‚ã«è¿½åŠ 
        epgApiBase: EPG_API_BASE, 
        
        isTimeSpecification: false,
        searchOption: {
            keyword,
            name: true, description: true, extended: true,
            GR: true, BS: true, CS: true
        },
        reserveOption: {
            enable: true,
            allowEndLack: false,
            avoidDuplicate: true
        }
    };

    try {
        const r = await fetch('/proxy/rule', {
            method: 'POST',
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });
        const data = await r.json();
        
        if (data && data.error) {
            log(`è¿½åŠ ã‚¨ãƒ©ãƒ¼: ${data.error}`);
            alert(`è¿½åŠ å¤±æ•—: ${data.error}`);
            return;
        }

        log(`è¿½åŠ  OK: ãƒ«ãƒ¼ãƒ«ID ${data.id}`);
        alert("è¿½åŠ ã—ã¾ã—ãŸï¼");
    } catch(e){
        log("è¿½åŠ ã‚¨ãƒ©ãƒ¼: " + e.message);
        alert("è¿½åŠ å¤±æ•—");
    }
}
function searchExternal(type) {
    const keyword = document.getElementById('keywordInput').value.trim();
    if (!keyword) {
        alert("ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
    }

    let url = "";
    const q = encodeURIComponent(keyword);

    switch (type) {
        case "duck":
            url = `https://duckduckgo.com/?q=${q}`;
            break;
        case "google":
            url = `https://www.google.com/search?q=${q}`;
            break;
        case "wiki":
            url = `https://ja.wikipedia.org/wiki/Special:Search?search=${q}`;
            break;
    }

    window.open(url, "_blank");
}

</script>
</body>
</html>
